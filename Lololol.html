<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Posy Motion Extractor V2 - Stable</title>
    <style>
        :root {
            --bg-main: #0a0a0a;
            --bg-panel: #141414;
            --text-primary: #f0f0f0;
            --text-secondary: #a0a0a0;
            --accent: #00e676; /* Green accent */
            --danger: #ff5252;
        }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-main);
            color: var(--text-primary);
            margin: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* --- Sidebar Controls --- */
        .controls-panel {
            width: 340px;
            background-color: var(--bg-panel);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            border-right: 1px solid #333;
            overflow-y: auto;
        }

        h1 { margin: 0; font-size: 1.4rem; color: var(--accent); }
        h2 { margin: 15px 0 5px 0; font-size: 0.9rem; text-transform: uppercase; color: var(--text-secondary); letter-spacing: 1px; }

        .btn-group { display: flex; gap: 10px; }
        
        .btn, .file-label {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 6px;
            background-color: #2a2a2a;
            color: var(--text-primary);
            cursor: pointer;
            font-weight: 600;
            text-align: center;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn:hover, .file-label:hover { background-color: #3a3a3a; }
        .btn.active { background-color: var(--accent); color: #000; }
        .btn.primary { background-color: var(--accent); color: #000; font-size: 1.1rem; }
        .btn.stop { background-color: var(--danger); color: white; }

        input[type="file"] { display: none; }

        /* Sliders and Options */
        .control-item { background: #1f1f1f; padding: 12px; border-radius: 8px; }
        .slider-header { display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 0.9rem; }
        input[type="range"] { width: 100%; accent-color: var(--accent); cursor: pointer;}
        
        .checkbox-label {
            display: flex; align-items: center; gap: 10px; cursor: pointer; font-size: 0.95rem;
        }
        input[type="checkbox"] { width: 18px; height: 18px; accent-color: var(--accent); }

        /* --- Main Viewport --- */
        .viewport-container {
            flex: 1;
            position: relative;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            max-width: 100%; max-height: 100%;
            object-fit: contain;
            /* Initial filter to ensure grey world look */
            filter: grayscale(100%) contrast(120%); 
        }

        /* Overlays */
        .status-overlay {
            position: absolute;
            top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: bold;
            display: none; /* Hidden by default */
        }
        .status-overlay.loading { color: #ffd700; display: block; }
        .status-overlay.ready { color: var(--accent); display: block; }
        .status-overlay.error { color: var(--danger); display: block; }

        .start-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: none; /* Hidden until file loaded */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        /* Hidden Elements */
        #sourceVideo { display: none; }
    </style>
</head>
<body>

    <div class="controls-panel">
        <h1>Posy Motion Extractor V2</h1>

        <h2>1. Ngu·ªìn Video (Input)</h2>
        <div class="btn-group">
            <button id="btnWebcam" class="btn">üì∑ Webcam Live</button>
            <label class="file-label">
                üìÅ T·∫£i Video l√™n
                <input type="file" id="inpFile" accept="video/mp4,video/webm,video/ogg">
            </label>
        </div>
        <button id="btnStop" class="btn stop" style="display: none; margin-top: 10px;">‚èπ D·ª´ng l·∫°i (Stop)</button>

        <h2>2. C·∫•u h√¨nh Posy (Core)</h2>
        <div class="control-item">
            <div class="slider-header">
                <span>üïí ƒê·ªô tr·ªÖ (Time Shift)</span>
                <span id="valDelay" style="color: var(--accent);">5 Frames</span>
            </div>
            <input type="range" id="rngDelay" min="1" max="60" value="5" step="1">
            <div style="font-size: 0.75rem; color: #777; margin-top: 5px;">
                Th·∫•p: Chuy·ªÉn ƒë·ªông nhanh. Cao: Chuy·ªÉn ƒë·ªông ch·∫≠m.
            </div>
        </div>

        <h2>3. T√≠nh nƒÉng th√∫ v·ªã (Fun & Visuals)</h2>
        
        <div class="control-item" style="background: #252525; border: 1px solid #444;">
            <div class="slider-header">
                <span>‚ú® V·ªát chuy·ªÉn ƒë·ªông (Trails/Fade)</span>
                <span id="valTrails" style="color: var(--accent);">Th·∫•p</span>
            </div>
            <input type="range" id="rngTrails" min="0" max="0.4" value="0.05" step="0.01">
             <div style="font-size: 0.75rem; color: #777; margin-top: 5px;">
                 Gi·ªØ l·∫°i t√†n d∆∞ c·ªßa chuy·ªÉn ƒë·ªông. K√©o cao ƒë·ªÉ t·∫°o hi·ªáu ·ª©ng "b√≥ng ma".
            </div>
        </div>

        <div class="control-item">
            <div class="slider-header">
                <span>üåó T∆∞∆°ng ph·∫£n (Contrast)</span>
                <span id="valContrast">150%</span>
            </div>
            <input type="range" id="rngContrast" min="100" max="400" value="150">
        </div>

        <div class="control-item">
             <label class="checkbox-label">
                <input type="checkbox" id="chkColor">
                <span>üé® Gi·ªØ m√†u g·ªëc (B·ªè Grayscale)</span>
            </label>
        </div>

    </div>


    <div class="viewport-container">
        <canvas id="outputCanvas"></canvas>
        
        <div id="statusBox" class="status-overlay">S·∫µn s√†ng</div>

        <div id="startOverlay" class="start-overlay">
            <h3 style="margin-bottom: 20px;">Video ƒë√£ t·∫£i xong!</h3>
            <button id="btnStartProcess" class="btn primary" style="padding: 15px 40px; font-size: 1.2rem;">
                ‚ñ∂Ô∏è B·∫Øt ƒë·∫ßu X·ª≠ l√Ω (Start Processing)
            </button>
        </div>
    </div>

    <video id="sourceVideo" muted playsinline loop crossorigin="anonymous"></video>


    <script>
        // === SETUP ===
        const video = document.getElementById('sourceVideo');
        const canvas = document.getElementById('outputCanvas');
        // Use '2d' context. 'willReadFrequently' might help on some browsers but can hurt others. 
        // Testing without it first for V2 stability.
        const ctx = canvas.getContext('2d'); 

        // Controls Elements
        const btnWebcam = document.getElementById('btnWebcam');
        const inpFile = document.getElementById('inpFile');
        const btnStop = document.getElementById('btnStop');
        const btnStartProcess = document.getElementById('btnStartProcess');
        
        const rngDelay = document.getElementById('rngDelay');
        const valDelay = document.getElementById('valDelay');
        const rngTrails = document.getElementById('rngTrails');
        const valTrails = document.getElementById('valTrails');
        const rngContrast = document.getElementById('rngContrast');
        const valContrast = document.getElementById('valContrast');
        const chkColor = document.getElementById('chkColor');

        // Overlay Elements
        const statusBox = document.getElementById('statusBox');
        const startOverlay = document.getElementById('startOverlay');

        // State Variables
        let isProcessing = false;
        let animationId = null;
        let frameBuffer = [];
        let videoSourceType = null; // 'webcam' or 'file'

        // === UI HELPERS ===
        function showStatus(msg, type) {
            statusBox.textContent = msg;
            statusBox.className = 'status-overlay ' + type;
        }
        function hideStatus() { statusBox.style.display = 'none'; }

        function resetUIState() {
            btnWebcam.classList.remove('active');
            startOverlay.style.display = 'none';
            btnStop.style.display = 'none';
            hideStatus();
            // Reset filter visually
            updateFilters(); 
        }

        // === CORE LOGIC: START / STOP ===

        async function stopEverything() {
            isProcessing = false;
            if (animationId) cancelAnimationFrame(animationId);
            video.pause();
            
            // Stop Webcam Stream if active
            if (video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
                video.srcObject = null;
            }
            // Revoke File URL if active
            if (video.src && video.src.startsWith('blob:')) {
                 URL.revokeObjectURL(video.src);
                 video.removeAttribute('src');
            }

            // Clear Buffer Memory rigorously
            frameBuffer.forEach(bmp => bmp.close());
            frameBuffer = [];

            // Clear Canvas
            ctx.clearRect(0,0, canvas.width, canvas.height);
            resetUIState();
        }

        function prepareVideoForProcessing() {
            // Set canvas size to match video
            canvas.width = video.videoWidth || 640;
            canvas.height = video.videoHeight || 480;
            
            resetUIState();
            btnStop.style.display = 'block'; // Show stop button
            
            if (videoSourceType === 'webcam') {
                // Webcam starts immediately
                video.play();
                startProcessingLoop();
            } else {
                // Files wait for user to click "Start"
                startOverlay.style.display = 'flex';
            }
        }

        function startProcessingLoop() {
            if (isProcessing) return;
            startOverlay.style.display = 'none';
            showStatus("ƒêang x·ª≠ l√Ω chuy·ªÉn ƒë·ªông...", "ready");
            isProcessing = true;
            video.play(); // Ensure it's playing
            processFrame();
        }


        // === CORE LOGIC: THE RENDERING LOOP (The Magic) ===

        async function processFrame() {
            if (!isProcessing || video.paused || video.ended) {
                if (isProcessing) animationId = requestAnimationFrame(processFrame);
                return;
            }

            // 1. Frame Buffering (Essential for Time Shift)
            // Grab frame as high-performance ImageBitmap
            const currentBitmap = await createImageBitmap(video);
            frameBuffer.push(currentBitmap);

            const delaySetting = parseInt(rngDelay.value);
            
            // Memory Management: Keep buffer size just right.
            // Delay + 2 gives us a tiny safety margin.
            while (frameBuffer.length > delaySetting + 2) {
                const oldFrame = frameBuffer.shift();
                oldFrame.close(); // VITAL: Release GPU memory immediately
            }

            // 2. Wait for Buffer to fill
            if (frameBuffer.length <= delaySetting) {
                showStatus(`ƒêang ƒë·ªám: ${frameBuffer.length}/${delaySetting} frames`, "loading");
                // Optional: Show live video while buffering
                ctx.drawImage(currentBitmap, 0, 0); 
                animationId = requestAnimationFrame(processFrame);
                return;
            } else {
                 hideStatus();
            }

            // 3. Get "Now" and "Then" frames
            // The oldest frame in the buffer is the delayed one.
            const delayedFrame = frameBuffer[0];
            // The newest frame is the current one.
            const currentFrame = frameBuffer[frameBuffer.length - 1];

            // --- RENDERING THE POSY EFFECT ---

            // A. "Fun Feature": Motion Trails / Fade
            // Instead of clearing the canvas, draw a semi-transparent black layer.
            // This makes previous frames slowly fade out instead of disappearing instantly.
            const trailAlpha = parseFloat(rngTrails.value);
            ctx.globalCompositeOperation = 'source-over';
            ctx.fillStyle = `rgba(0, 0, 0, ${trailAlpha})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);


            // B. The Posy Technique: Invert + 50% Opacity
            
            // Layer 1: Delayed Frame (Normal)
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = 1.0;
            // Important: We apply grayscale/contrast filters using CSS on the canvas element itself,
            // not here in the JS loop, for MUCH better performance.
            ctx.drawImage(delayedFrame, 0, 0);

            // Layer 2: Current Frame (Inverted + 50% Opacity)
            // When an inverted image at 50% is laid over its non-inverted self, they cancel out to grey.
            // If they have moved, they don't cancel out, revealing color/luminance.
            ctx.globalCompositeOperation = 'difference'; // Using difference for stronger pop in V2, then inverting visually via CSS
            
            // Alternative pure Posy method (commented out as 'difference' often looks punchier)
            // ctx.globalCompositeOperation = 'source-over';
            // ctx.filter = 'invert(100%)'; // Requires context support, slower than CSS approach below
            
            ctx.globalAlpha = 0.5; 
            ctx.drawImage(currentFrame, 0, 0);

            // Reset settings for next frame
            ctx.globalAlpha = 1.0;
            // ctx.filter = 'none';

            // Loop
            animationId = requestAnimationFrame(processFrame);
        }


        // === EVENT LISTENERS ===

        // 1. Webcam Input
        btnWebcam.addEventListener('click', async () => {
            await stopEverything();
            videoSourceType = 'webcam';
            showStatus("ƒêang m·ªü Webcam...", "loading");
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: {ideal: 1280}, height: {ideal: 720} } });
                video.srcObject = stream;
                // Wait for metadata to know dimensions
                video.onloadedmetadata = () => prepareVideoForProcessing();
                btnWebcam.classList.add('active');
            } catch (err) {
                showStatus("L·ªói Webcam: " + err.message, "error");
                videoSourceType = null;
            }
        });

        // 2. File Input
        inpFile.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            await stopEverything();
            videoSourceType = 'file';
            showStatus("ƒêang t·∫£i file video...", "loading");
            
            const url = URL.createObjectURL(file);
            video.src = url;
            video.load(); // Required for some browsers to trigger metadata load
            video.onloadedmetadata = () => prepareVideoForProcessing();
            video.onerror = () => showStatus("L·ªói kh√¥ng th·ªÉ ƒë·ªçc file video n√†y.", "error");
        });

        // 3. Start Processing Button (for files)
        btnStartProcess.addEventListener('click', () => {
            startProcessingLoop();
        });

        // 4. Stop Button
        btnStop.addEventListener('click', stopEverything);


        // === SLIDER UI UPDATES ===
        rngDelay.addEventListener('input', (e) => valDelay.textContent = `${e.target.value} Frames`);
        
        // Update trails label text based on value
        rngTrails.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            let text = "Trung b√¨nh";
            if(val < 0.02) text = "R·∫•t d√†i (B√≥ng ma)";
            else if(val < 0.1) text = "D√†i";
            else if(val > 0.3) text = "Ng·∫Øn (M·∫∑c ƒë·ªãnh)";
            valTrails.textContent = text;
        });

        // Function to update CSS filters on the canvas
        function updateFilters() {
            const contrast = rngContrast.value;
            const grayscale = chkColor.checked ? '0%' : '100%';
            // We use 'invert(1)' here because in the JS loop we used 'difference' composite mode.
            // Difference results in Black for static objects. We want Grey for static objects (Posy style).
            // Inverting the black difference image creates the white/grey "world".
            canvas.style.filter = `grayscale(${grayscale}) contrast(${contrast}%) invert(1)`;
            
            valContrast.textContent = `${contrast}%`;
        }

        rngContrast.addEventListener('input', updateFilters);
        chkColor.addEventListener('change', updateFilters);

        // Initialize filters
        updateFilters();

    </script>
</body>
    </html>
    
