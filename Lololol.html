<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Motion Extraction Tool (Posy Technique)</title>
    <style>
        :root {
            --bg-color: #121212;
            --panel-color: #1e1e1e;
            --text-color: #e0e0e0;
            --accent-color: #00bcd4;
            --accent-hover: #008ba3;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* Sidebar Controls */
        .controls {
            width: 320px;
            background-color: var(--panel-color);
            padding: 20px;
            box-shadow: 2px 0 10px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
            z-index: 10;
        }

        h1 { font-size: 1.2rem; margin: 0 0 10px 0; color: var(--accent-color); }
        h2 { font-size: 0.9rem; margin: 10px 0 5px 0; text-transform: uppercase; opacity: 0.7; letter-spacing: 1px; }

        .btn-group { display: flex; gap: 10px; margin-bottom: 10px; }
        
        button, .file-upload {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 5px;
            background-color: #333;
            color: white;
            cursor: pointer;
            transition: 0.2s;
            font-size: 0.9rem;
            text-align: center;
        }

        button:hover, .file-upload:hover { background-color: #444; }
        button.active { background-color: var(--accent-color); color: #000; font-weight: bold; }

        input[type="file"] { display: none; }

        /* Sliders */
        .slider-container { margin-bottom: 15px; }
        .slider-label { display: flex; justify-content: space-between; font-size: 0.85rem; margin-bottom: 5px; }
        input[type="range"] { width: 100%; cursor: pointer; accent-color: var(--accent-color); }

        /* Info Box */
        .info-box {
            font-size: 0.8rem;
            background: #2a2a2a;
            padding: 10px;
            border-radius: 5px;
            line-height: 1.4;
            color: #aaa;
        }

        /* Main Viewport */
        .viewport {
            flex: 1;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            background-image: 
                linear-gradient(45deg, #1a1a1a 25%, transparent 25%), 
                linear-gradient(-45deg, #1a1a1a 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #1a1a1a 75%), 
                linear-gradient(-45deg, transparent 75%, #1a1a1a 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }

        canvas {
            max-width: 100%;
            max-height: 100%;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }

        video { display: none; } /* Hide source video */
        
        .loading {
            position: absolute;
            color: var(--accent-color);
            font-size: 1.5rem;
            display: none;
        }

    </style>
</head>
<body>

    <div class="controls">
        <h1>Motion Extractor</h1>
        
        <h2>1. Ngu·ªìn Video (Input)</h2>
        <div class="btn-group">
            <button id="btnWebcam">üé• Webcam</button>
            <label class="file-upload">
                üìÇ Upload
                <input type="file" id="inpFile" accept="video/*">
            </label>
        </div>

        <h2>2. K·ªπ thu·∫≠t (Mode)</h2>
        <div class="slider-container">
            <select id="selMode" style="width: 100%; padding: 8px; background: #333; color: white; border: none; border-radius: 5px;">
                <option value="posy">Posy Original (Grey World)</option>
                <option value="difference">Difference (High Contrast)</option>
                <option value="ghost">Ghost Trail (Overlay)</option>
            </select>
        </div>

        <h2>3. Tham s·ªë (Settings)</h2>
        
        <div class="slider-container">
            <div class="slider-label">
                <span>Time Shift (Delay)</span>
                <span id="valDelay">5 frames</span>
            </div>
            <input type="range" id="rngDelay" min="1" max="120" value="5">
            <div class="info-box">
                Th·∫•p (1-5): Ph√°t hi·ªán chuy·ªÉn ƒë·ªông nhanh.<br>
                Cao (30+): Ph√°t hi·ªán chuy·ªÉn ƒë·ªông r·∫•t ch·∫≠m (m√¢y, m·∫∑t trƒÉng, c√¢y m·ªçc).
            </div>
        </div>

        <div class="slider-container">
            <div class="slider-label">
                <span>C∆∞·ªùng ƒë·ªô / Contrast</span>
                <span id="valContrast">100%</span>
            </div>
            <input type="range" id="rngContrast" min="100" max="500" value="100">
        </div>

         <div class="slider-container">
            <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                <input type="checkbox" id="chkColor">
                <span>üé® Gi·ªØ m√†u g·ªëc (Keep Color)</span>
            </label>
        </div>

        <div style="margin-top: auto; font-size: 0.75rem; text-align: center; color: #666;">
            Inspired by Posy's "Motion Extraction"<br>
            Processing done locally in browser.
        </div>
    </div>

    <div class="viewport">
        <div class="loading" id="loadingText">ƒêang x·ª≠ l√Ω...</div>
        <canvas id="outputCanvas"></canvas>
    </div>

    <video id="sourceVideo" autoplay loop muted playsinline></video>

    <script>
        // --- Elements ---
        const video = document.getElementById('sourceVideo');
        const canvas = document.getElementById('outputCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true }); // Optimize for read
        const btnWebcam = document.getElementById('btnWebcam');
        const inpFile = document.getElementById('inpFile');
        const loadingText = document.getElementById('loadingText');
        
        // Controls
        const selMode = document.getElementById('selMode');
        const rngDelay = document.getElementById('rngDelay');
        const valDelay = document.getElementById('valDelay');
        const rngContrast = document.getElementById('rngContrast');
        const valContrast = document.getElementById('valContrast');
        const chkColor = document.getElementById('chkColor');

        // --- State ---
        let isStreaming = false;
        let frameBuffer = []; // Buffer to store ImageBitmaps
        let animationId;
        let maxBufferLength = 120; // Cap max frames to prevent memory crash

        // --- Event Listeners ---

        // 1. Webcam Input
        btnWebcam.addEventListener('click', async () => {
            stopProcessing();
            try {
                loadingText.style.display = 'block';
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } });
                video.srcObject = stream;
                video.onloadedmetadata = () => {
                    startProcessing();
                };
                btnWebcam.classList.add('active');
            } catch (err) {
                alert("Kh√¥ng th·ªÉ truy c·∫≠p Webcam: " + err.message);
                loadingText.style.display = 'none';
            }
        });

        // 2. File Input
        inpFile.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            stopProcessing();
            loadingText.style.display = 'block';
            const url = URL.createObjectURL(file);
            video.srcObject = null;
            video.src = url;
            video.onloadedmetadata = () => {
                startProcessing();
            };
            btnWebcam.classList.remove('active');
        });

        // 3. Sliders UI Updates
        rngDelay.addEventListener('input', (e) => {
            valDelay.textContent = `${e.target.value} frames`;
            // Trim buffer if delay is reduced to save memory immediately
            if (frameBuffer.length > parseInt(e.target.value) + 5) {
                const removeCount = frameBuffer.length - (parseInt(e.target.value) + 1);
                for(let i=0; i<removeCount; i++) {
                    const item = frameBuffer.shift();
                    if(item) item.close();
                }
            }
        });

        rngContrast.addEventListener('input', (e) => {
            valContrast.textContent = `${e.target.value}%`;
            canvas.style.filter = `contrast(${e.target.value}%)`;
        });

        // --- Core Logic ---

        function stopProcessing() {
            if (animationId) cancelAnimationFrame(animationId);
            // Clear buffer and release memory
            frameBuffer.forEach(bmp => bmp.close());
            frameBuffer = [];
            isStreaming = false;
            loadingText.style.display = 'none';
        }

        function startProcessing() {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            loadingText.style.display = 'none';
            isStreaming = true;
            processFrame();
        }

        async function processFrame() {
            if (!isStreaming || video.paused || video.ended) {
                animationId = requestAnimationFrame(processFrame);
                return;
            }

            // 1. Capture Current Frame efficiently
            const currentBitmap = await createImageBitmap(video);
            
            // 2. Add to Buffer
            frameBuffer.push(currentBitmap);

            // 3. Buffer Management (Circular-ish)
            const delay = parseInt(rngDelay.value);
            
            // If buffer isn't full enough for the delay yet, just show current frame or wait
            if (frameBuffer.length <= delay) {
                // Draw waiting screen or current frame
                ctx.globalCompositeOperation = 'source-over';
                ctx.drawImage(currentBitmap, 0, 0);
                animationId = requestAnimationFrame(processFrame);
                return; 
            }

            // Remove old frames if buffer is too big (Memory safety)
            while (frameBuffer.length > delay + 2) {
                const oldFrame = frameBuffer.shift();
                oldFrame.close(); // Important: release GPU memory
            }

            // 4. Get the "Past" frame
            // The frame at index 0 is the oldest. With delay N, we want the frame N steps ago.
            // Since we keep buffer size around Delay+1, the oldest frame is the delayed one.
            const delayedFrame = frameBuffer[0];
            const currentFrame = frameBuffer[frameBuffer.length - 1];

            // 5. Render based on Mode
            const mode = selMode.value;
            const keepColor = chkColor.checked;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (mode === 'posy') {
                // --- POSY TECHNIQUE (Invert + 50% Opacity) ---
                // Result is Grey (128,128,128) where static.
                
                // Step A: Draw Current Frame
                ctx.globalCompositeOperation = 'source-over';
                ctx.globalAlpha = 1.0;
                if (!keepColor) ctx.filter = 'grayscale(100%)'; // Posy usually does grayscale
                else ctx.filter = 'none';
                ctx.drawImage(currentFrame, 0, 0);

                // Step B: Draw Delayed Frame (Inverted + 50% Opacity)
                ctx.globalCompositeOperation = 'source-over'; // Just layer it on top
                ctx.globalAlpha = 0.5; // 50% transparency
                // Invert the delayed frame
                if (!keepColor) ctx.filter = 'grayscale(100%) invert(100%)';
                else ctx.filter = 'invert(100%)';
                
                ctx.drawImage(delayedFrame, 0, 0);
                
                // Reset for next loop
                ctx.globalAlpha = 1.0;
                ctx.filter = 'none';

            } else if (mode === 'difference') {
                // --- DIFFERENCE MODE ---
                // Black where static, Bright where moving.
                
                ctx.globalCompositeOperation = 'source-over';
                ctx.drawImage(currentFrame, 0, 0);
                
                ctx.globalCompositeOperation = 'difference';
                ctx.drawImage(delayedFrame, 0, 0);

                if (!keepColor) {
                    // If user wants B&W difference, we can saturate output
                    ctx.globalCompositeOperation = 'saturation';
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0,0, canvas.width, canvas.height);
                }

            } else if (mode === 'ghost') {
                // --- GHOST / ECHO MODE ---
                ctx.globalCompositeOperation = 'source-over';
                ctx.globalAlpha = 1.0;
                ctx.drawImage(currentFrame, 0, 0);
                
                ctx.globalCompositeOperation = 'screen'; // Or overlay
                ctx.globalAlpha = 0.5;
                ctx.drawImage(delayedFrame, 0, 0);
                
                ctx.globalAlpha = 1.0;
            }

            // Reset Composite
            ctx.globalCompositeOperation = 'source-over';

            animationId = requestAnimationFrame(processFrame);
        }

        // Initialize slider values
        valDelay.textContent = `${rngDelay.value} frames`;
        valContrast.textContent = `${rngContrast.value}%`;

    </script>
</body>
</html>
